'use strict'

exports.render = render

const fs = require('fs')
const path = require('path')
const util = require('util')

const marked = require('marked')
const prism = require('prismjs')
const prismLoadLanguages = require('prismjs/components/index.js')

const nenb = require('..')
const utils = require('./utils')
const pkg = require('../package.json')

const log = require('./logger')(__filename)

const directives = nenb.directives
const fsWriteFile = util.promisify(fs.writeFile)
const E = utils.escapeHtml

prismLoadLanguages()

marked.setOptions({
  gfm: true,
  tables: true
})

async function render (fileName, sections, outFileName) {
  log.debug(`rendering ${outFileName}`)
  const lines = []

  const context = {
    data: {
      document: {
        title: path.basename(fileName).replace(/\.nenb\.md$/, '')
      }
    }
  }

  for (let section of sections) {
    if (section.isDirective()) {
      if (section.name === 'doc') {
        const directive = directives[section.name]
        directive.run(context, section.attrs)
      }
    }
  }

  generateHeader(context, sections, lines)
  await generateBody(context, sections, lines)
  generateTrailer(context, sections, lines)

  const content = lines.join('\n')
  await fsWriteFile(outFileName, content)

  return [outFileName]
}

async function generateBody (context, sections, lines) {
  for (let section of sections) {
    // process directives
    if (section.isDirective()) {
      // if the showDirective attr is set, generate the source
      if (section.attr('showDirective') != null) {
        lines.push('<!-- directive source -->')
        lines.push('<pre class=nenb-block-source>')
        lines.push(colorize(section.toTXT(), 'markdown'))
        lines.push('</pre>')
        lines.push('')
      }

      if (section.name === 'doc') continue

      const directive = directives[section.name]
      if (directive == null) {
        log(`no directive for ${section.name} available from ${getLocation(section)}, skipping`)
        continue
      }

      const content = directive.run(context, section.attrs)
      if (content == null) continue

      lines.push(content)
      lines.push('')
      continue
    }

    // process blocks
    const showAllAttr = section.attr('showAll')
    const showAttr = section.attr('show') || showAllAttr
    if (showAttr) {
      lines.push('<!-- block source -->')
      lines.push('<div class=nenb-block-source>')
      lines.push('<pre>')
      const source = section.lines.join('\n')
      lines.push(colorize(source, section.attr('lang')))
      lines.push('</pre>')

      if (showAllAttr) {
        lines.push('    <!-- attrs -->')
        lines.push('    <hr>')
        lines.push('    <table class=nenb-block-source-attrs>')
        for (const attrName of section.attrNames()) {
          const attrValue = section.attr(attrName)
          lines.push('      <tr>')
          lines.push(`        <td><tt>${E(attrName)}</tt></td>`)
          lines.push(`        <td>${E(attrValue)}</td>`)
          lines.push('      </tr>')
        }
        lines.push('    </table>')
      }
      lines.push('</div>')
      lines.push('')
    }

    const lang = section.attr('lang')
    const renderer = section.attr('render') || lang

    let directive = directives[`render-${renderer}`]
    if (directive == null) {
      log(`no renderer for ${renderer} available from ${getLocation(section)}, using txt`)
      directive = directives[`render-txt`]
      continue
    }

    lines.push('<!-- block rendered -->')
    try {
      var output = directive.run(context, section.attrs, section.lines.join('\n'))
    } catch (err) {
      logError(lines, err, section)
      continue
    }

    try {
      output = await Promise.resolve(output)
    } catch (err) {
      logError(lines, err, section)
      continue
    }

    lines.push(output)
    lines.push('')
  }

  const attribution = []
  attribution.push('<hr>')
  attribution.push('generated by')
  attribution.push(`<a href="${E(pkg.homepage)}">${E(path.basename(pkg.name))}`)
  attribution.push(`${E(pkg.version)}</a>`)

  lines.push('<div class="nenb-attribution"><p>')
  lines.push(attribution.join(' '))
  lines.push('</p></div>')
  lines.push('')
}

function logError (lines, err, section) {
  log(`error processing ${section.lang} from ${getLocation(section)}, skipping`)
  log(err)
  lines.push('<pre class=nenb-error>')
  lines.push(`error processing ${E(section.lang)} from ${E(getLocation(section))}`)
  lines.push(E(err.toString()))
  lines.push('</pre>')
  lines.push('')
}

function generateHeader (context, sections, lines) {
  const title = context.data.document.title || 'untitled'

  let icon = ''
  if (context.data.document.icon) {
    icon = `\n<link rel="shortcut icon" href="${E(context.data.document.icon)}" />`
  }

  const header = `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible"        content="IE=edge">
<meta name="viewport"                     content="width=device-width">
<meta name="mobile-web-app-capable"       content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>${E(title)}</title>${icon}

<script>
const data = {}
</script>

</head>
<body>`.trim()
  lines.push(header, '')

  if (context.data.document.bodyTitle == null) return

  lines.push('<!-- auto-generated title -->')
  lines.push(`<h1>${E(title)}</h1>`)
  lines.push('')
}

function generateTrailer (context, sections, lines) {
  const defaultCSS = getDefaultCSS()

  lines.push('<style>')
  lines.push(defaultCSS)
  lines.push('</style>')
  lines.push('')

  lines.push('</body>')
  lines.push('</html>')
}

function colorize (source, lang) {
  const prismSupportedLang = prism.languages[lang] != null
  if (!prismSupportedLang) {
    log.debug(`colorize(): prism does not support "${lang}"`)
    return E(source)
  }

  return prism.highlight(source, prism.languages[lang])
}

function getDefaultCSS () {
  const cssFileName = path.join(__dirname, 'default-style.css')
  const content = fs.readFileSync(cssFileName, 'utf8')
  return content.trim()
}

function getLocation (section) {
  return `${section.fileName}:${section.lineNumber}`
}
